(in-package :yggdrasil)

(defun rectangle-or-circle (object)
  (cond ((= (length object) 4)
	 :rectangle)
	((= (length object) 3)
	 :circle)
	(t :none)))

(defun collision-check-helper-rectangle-and-array (rect other)
  (cond ((equal (rectangle-or-circle other) :rectangle)
	 (rectangle-collision-check rect other))
	((equal (rectangle-or-circle other) :circle)
	 (rectangle-circle-collision-check rect other))
	(t (error "~a is neither a rectangle nor a cricle!" other))))


#||
;; Change to check if old-obj is rect
(defmethod collision-check ((object1 rectangle) (object2 rectangle) &optional old-obj);((object1 hitbox-rect) (object2 hitbox-rect))
  (unless (typep old-obj 'rectangle) (error "old object of wrong type"))
  (if (typep old-obj 'rectangle) 
      (rect-collision-check (get-range old-obj object1) object2)
      (rect-collision-check object1 object2)))||#


(defmethod collision-check ((object1 rectangle) (object2 array))
  (collision-check-helper-rectangle-and-array object1 object2))

(defmethod collision-check ((object1 array) (object2 rectangle))
  (collision-check-helper-rectangle-and-array object2 object1))

(defmethod collision-check ((object1 rectangle) (object2 rectangle))
  (rectangle-collision-check object1 object2))

(defmethod collision-check ((object1 array) (object2 array))
  (let ((obj1-type (rectangle-or-circle object1))
	(obj2-type (rectangle-or-circle object2)))
    (cond ((equal obj1-type :none) (error "~a is not a rectangle or circle array" object1))
	  ((equal obj2-type :none) (error "~a is not a rectangle or circle array" object2))
	  ((and (equal obj1-type :rectangle) (equal obj1-type obj2-type))
	   (rectangle-collision-check object1 object2))
	  ((and (equal obj1-type :circle) (equal obj1-type obj2-type))
	   (circle-collision-check object1 object2))
	  (t (rectangle-circle-collision-check object1 object2)))))


(defun rectangle-direction-collision (rect1 rect2)
  (when (collision-check rect1 rect2)
    (let ((wy (* (+ (w rect1) (w rect2)) (- (y rect1) (y rect2))))
	  (hx (* (+ (h rect1) (h rect2)) (- (x rect1) (x rect2)))))
      (if (> wy hx)
	  (if (> wy (- hx))
	      :top
	      :left)
	  (if (> wy (- hx))
	      :right
	      :bottom)))))



#||
(defmethod collision-check ((object1 rectangle) (object2 circle) &optional old-obj);((object1 hitbox-rect) (object2 hitbox-circle))
  (if (typep old-obj 'rect)
      (rect-circle-collision-check (get-range old-obj object1) object2)
      (rect-circle-collision-check object1 object2)))

(defmethod collision-check ((object1 circle) (object2 rect) &optional old-obj);((object1 hitbox-circle) (object2 hitbox-rect))
  (if (typep old-obj 'circle) 

      ;; If object1 and old-object are in the same position, do circle collision, if not do range collision.
      (if (object-same-pos-p object1 old-obj)
	  (rect-circle-collision-check object2 object1)
	  (rect-collision-check (get-range old-obj object1) object2))
      (rect-circle-collision-check object2 object1)))

(defmethod collision-check ((object1 circle) (object2 circle) &optional old-obj);((object1 hitbox-circle) (object2 hitbox-circle))
  (if (typep old-obj 'rect)
      (if (object-same-pos-p object1 old-obj) 
	  (circle-collision-check object1 object2)
	  (rect-circle-collision-check (get-range old-obj object1) object2))
      (circle-collision-check object1 object2)))

||#



(defun get-range-positions (old-obj object &aux sx ex sy ey)
  "Get the starting and ending position between the old and new object"
  (if (< (x old-obj) (x object))
      (setf sx (x old-obj) ex (x object))
      (setf ex (x old-obj) sx (x object)))
  
  (if (< (y old-obj) (y object))
      (setf sy (y old-obj) ey (y object))
      (setf ey (y old-obj) sy (y object)))

  ;; reduce the end position by the starting position to make the range between start\end.
  (setf ex (- ex sx)
	ey (- ey sy))
  (list sx sy ex ey))
  
(defmethod get-range (old-obj object &aux sx sy ex ey))

(defmethod get-range ((old-obj circle) (object circle) &aux (pos (get-range-positions old-obj object)))
  "Get the start and end position(size) of the range, only registers about half of the circle,
so end position uses standard non-range collision"
  (make-instance 'sdl:rectangle :x (elt pos 0) :y  (elt pos 1)
 ; (make-instance 'rect :x (- (elt pos 0) (r object)) :y (- (elt pos 1) (r object))
		 :w (+ (elt pos 2) (r object)) :h (+ (elt pos 3)  (r object)))) 
	;	 :w (+ (elt pos 2) (* 2 (r object))) :h (+ (elt pos 3) (* 2 (r object)))))

;make generic documented
(defmethod get-range ((old-obj rectangle) (object rectangle)) (get-range-rect-helper old-obj object))


(defun object-same-pos-p (object1 object2)
  "Checks if object1 and object2 are at the same position, a.k.a, not moved"
  (if (and (= (x object1) (x object2)) (= (y object1) (y object2)))
      t
      nil))

#||

(defgeneric mouse-collision-check (object &optional mouse)
  (:documentation "Collision checking between object and the current position of the mouse"))

(defmethod mouse-collision-check ((object rect) &optional (mouse (vector (sdl:mouse-x) (sdl:mouse-y))))
  (and (pixel-rect-collision-check (x object) (y object) (w object) (h object) (aref mouse 0) (aref mouse 1))))

(defmethod mouse-collision-check ((object sdl:surface) &optional (mouse (vector (sdl:mouse-x) (sdl:mouse-y))))
  (and (pixel-rect-collision-check (x object) (y object) (w object) (h object) (aref mouse 0) (aref mouse 1))))

(defmethod mouse-collision-check ((object vector) &optional (mouse (vector (sdl:mouse-x) (sdl:mouse-y))))
  (and (pixel-rect-collision-check (aref object 0) (aref object 1) (aref object 2) (aref object 3) (elt mouse 0) (elt mouse 1))))


(defmethod mouse-collision-check ((object circle) &optional (mouse (vector (sdl:mouse-x) (sdl:mouse-y))))
  (if (pixel-circle-collision-check (x object) (y object) (r object) (elt mouse 0) (elt mouse 1))
      object
      nil))
(defmethod mouse-collision-check ((object rect) &optional (mouse (vector (sdl:mouse-x) (sdl:mouse-y))))
  (if (pixel-rect-collision-check (x object) (y object) (w object) (h object) (elt mouse 0) (elt mouse 1))
      object
      nil))
||#

;(defmethod mouse-collision-check (object)
;  nil)

(defun pixel-circle-collision-check (x y r px py)
  "pixel collision detection between pixel point and a circle"
  (let ((deltax (- x px ))
	(deltay (- y py)))
    (if (<= (+ (* deltax deltax) (* deltay deltay)) (* r r))
	t
	nil)))

(defun pixel-rect-collision-check (x y w h px py)
  "pixel collision detection between pixel point and a rect"
  (if (and (<= px (+ x w))
	   (>= px x)
	   (<= py (+ y h))
	   (>= py y))
      t
      nil))


(defun rectangle-circle-collision-check (rect circle)
  "Input: A rect and a cirlce object"
  (let ((deltax (- (x circle) (max (x rect) (min (x circle) (+ (x rect) (w rect))))))
	(deltay (- (y circle) (max (y rect) (min (y circle) (+ (y rect) (h rect)))))))
    (if (< (+ (* deltax deltax) (* deltay deltay)) (* (r circle) (r circle)))
	(list rect circle)
	nil)))

(defun rectangle-collision-check (rect1 rect2)
  "input: two rect objects"
    (if (and (< (x rect1) (+ (x rect2) (w rect2)))
	     (> (+ (x rect1) (w rect1)) (x rect2))
	     (< (y rect1) (+ (y rect2) (h rect2)))
	     (> (+ (y rect1) (h rect1)) (y rect2)))
	(progn
	  (list rect1 rect2)
	  )
	nil))

(defun circle-collision-check (circle1 circle2)
  "Input: two circle objects"
  (let* ((distx (- (x circle2) (x circle1)))
	 (disty (- (y circle2) (y circle1)))
	 (radius (+ (r circle1) (r circle2))))
    (if (< (+ (* distx distx) (* disty disty)) (* radius radius))
	t
	nil)))
  

#||

(defgeneric edge-collision-check (object &optional beyond)
  (:documentation "Checks if the [object] collides with the edges of the window, 
if beyond is set it'll only colide if the object is past the window"))

(defmethod edge-collision-check (object &optional (beyond nil))
  "No collision if not of a valid shape"
  nil)

(defmethod edge-collision-check ((object sdl:rectangle) &optional (beyond nil))
  "Edge collision for a rectangle instance"
  (edge-rect-collision object beyond))

(defmethod edge-collision-check ((object circle) &optional (beyond nil))
  "Edge collision for a rectangle instance"
  (edge-circle-collision object beyond))

(defun get-edge-dir (object dir &key (beyond nil))
  "Check if object is coliding with the chosen direction"
  (member dir (edge-collision-check object beyond) :test #'string=))
 ; (member dir (edge-rect-collision object beyond) :test #'string=))

(defun edge-rect-collision (rect beyond &aux (ex 0) (ey 0) (ew *width*) (eh *height*) (col nil))
  "Checks if rectangle collides with the edge of the window.
If beyond is set, will only be considered collision if object is past window"
  (when beyond
    (setf ex (- ex (w rect))
	  ey (- ey (h rect))
	  ew (+ ew (w rect))
	  eh (+ eh (h rect))))
  
   (when (<= (x rect) ex)
     (push 'left col))
   (when (>= (+ (x rect) (w rect)) ew)
    (push 'right col))
   (when (<= (y rect) ey)
    (push 'top col))
   (when (>= (+ (y rect) (h rect)) eh)
     (push 'bottom col))
   col)

(defun edge-circle-collision (circle beyond &aux (ex 0) (ey 0) (ew *width*) (eh *height*) (col nil))
  "Checks if circle collides with the edge of the window"
  (if beyond
      (progn
	(when (<= (x circle) (- ex (r circle)))
	  (push 'left col))
	(when (>= (- (x circle) (r circle)) ew)
	  (push 'right col))
	(when (<= (y circle) (- ey (r circle)))
	  (push 'top col))
	(when (>= (- (y circle) (r circle)) eh)
	  (push 'bottom col)))
      

      (progn
	(when (<= (x circle) (+ ex (r circle)))
	  (push 'left col))
	(when (>= (+ (x circle) (r circle)) ew)
	  (push 'right col))
	(when (<= (y circle) (+ (r circle) ey))
	  (push 'top col))
	(when (>= (+ (y circle) (r circle)) eh)
	  (push 'bottom col))))
  col)
  

||#
